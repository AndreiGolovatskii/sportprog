\begin{problem}{Connect and Disconnect}{connect.in}{connect.out}
{3 seconds (\textit{4 seconds for Java})}{256 Mebibytes}{}

% Problem author: Sergey Kopeliovich
% Text author: Sergey Kopeliovich
% Tests author: Sergey Kopeliovich

Вы когда-нибудь слышали про обход в глубину?
Например, используя этот алгоритм, вы можете проверить является ли
граф связным за время $O(E)$. Вы можете даже посчитать количество
компонент связности за то же время.

А вы когда нибудь слышали про систему непересекающихся множеств?
Используя эту структуру, вы можете быстро обрабатывать запросы ``Добавить ребро в граф'' и
``Посчитать количество компонент связности в графе''.

А вы когда-нибудь слышали о \textit{динамической} задаче связности?
В этой задаче вам необходимо обрабатывать три типа запросов:
\begin{enumerate}
  \setlength{\parskip}{-4pt}
  \setlength{\itemsep}{6pt}
  \item Добавить ребро в граф.
  \item Удалить ребро из графа.
  \item Посчитать количество компонент связности в графе.
\end{enumerate}

Граф является неориентированным. Изначально граф пустой.

\InputFile

В первой строке находятся два целых числа $N$ и $K$~--- количество вершин и количество
запросов, сответствено ($1 \le N \le 300\,000$, $0 \le K \le 300\,000$).
Следующие $K$ строк содержат запросы, по одному в строке.
Каждый запрос имеет один из трех типов:
\begin{enumerate}
  \setlength{\parskip}{-2pt}
  \setlength{\itemsep}{7pt}
  \item \t{+ $u$ $v$}: Добавить ребро между вершинами $u$ и $v$.
      Гарантируется, что такого ребра нет.
  \item \t{- $u$ $v$}: Удалить ребро между $u$ и $v$.
      Гарантируется, что такое ребро есть.
  \item \t{?}: Посчитать количество компонент связности в графе.
\end{enumerate}

Вершины пронумерованы целыми числами от $1$ до $N$. Во всех запросах $u \ne v$.

\OutputFile

Для каждого запроса `\t{?}' выведите количество компонент связности в момент запроса.

\Example
\begin{example}
\exmp{
5 11
?
+ 1 2
+ 2 3
+ 3 4
+ 4 5
+ 5 1
?
- 2 3
?
- 4 5
?
}{
5
1
1
2
}%
\end{example}

\end{problem}
